@{
    ViewData["Title"] = "Home Page";
}
<script src="~/lib/jsplumb/draggable.js"></script>
<script src="~/lib/jsplumb/jsplumb.js"></script>
<script src="~/lib/jsplumb/svg.js"></script>
<style>
    #FlowDesign, #FlowDesign > div {
        height: 90%;
        min-height: 650px;
    }

    .monitorObj {
        width: 100px;
        height: 60px;
        border: 1px solid #ccc;
        text-align: center;
        position: absolute;
        top: 0;
        left: 0;
    }

    #jsLayout {
        position: relative;
    }
</style>
<div id="FlowDesign" class="row">
    <h2 class="text-center">流程图设计界面</h2>
    <div class="col-sm-2">
        <div id="list" class="list-group">
            <a href="#" class="list-group-item" data-deviceType="Text" data-type="Text">
                <i class="glyphicon glyphicon-text-size"></i> 文本
            </a>
            <a href="#" class="list-group-item" data-deviceType="concentrator" data-type="concentrator">
                <i class="glyphicon glyphicon-bed"></i> 集中器
            </a>
            <a href="#" class="list-group-item" data-deviceType="water" data-type="water">
                <i class="glyphicon glyphicon-tint"></i> 水表
            </a>
            <a href="#" class="list-group-item" data-deviceType="electric" data-type="electric">
                <i class="glyphicon glyphicon-flash"></i> 电表
            </a>
            <a href="#" class="list-group-item" data-deviceType="gas" data-type="gas">
                <i class="glyphicon glyphicon-fire"></i> 汽表
            </a>
        </div>
    </div>
    <div class="col-sm-8  table-bordered" id="jsLayout">

    </div>
    <div class="col-sm-2">

    </div>
</div>
<script>
    (function () {


        var jspConfig = {
            lineColor: "#2f8e00",
            basicType: {
                connector: "StateMachine",
                paintStyle: { stroke: "red", strokeWidth: 4 },
                hoverPaintStyle: { stroke: "blue" },
                overlays: [
                    "Arrow"
                ]
            },
            endpointHoverStyle: {
                fill: "#216477",
                stroke: "#216477"
            },
            sourceEndpoint: {
                endpoint: "Dot",
                paintStyle: {
                    stroke: "#7AB02C",
                    fill: "transparent",
                    radius: 7,
                    strokeWidth: 1
                },
                connector: ["Flowchart", { stub: [40, 60], gap: 10, cornerRadius: 5, alwaysRespectStubs: true }],
                connectorStyle: {
                    strokeWidth: 2,
                    stroke: "#61B7CF",
                    joinstyle: "round",
                    outlineStroke: "white",
                    outlineWidth: 2
                },
                hoverPaintStyle: {
                    fill: "#216477",
                    stroke: "#216477"
                },
                connectorHoverStyle: {
                    strokeWidth: 3,
                    stroke: "#216477",
                    outlineWidth: 5,
                    outlineStroke: "white"
                },

            },
            targetEndpoint: {
                endpoint: "Dot",
                paintStyle: { fill: "#7AB02C", radius: 7 },
                hoverPaintStyle: {
                    fill: "#216477",
                    stroke: "#216477"
                },
                dropOptions: { hoverClass: "hover", activeClass: "active" },
                isTarget: true,
                overlays: [
                    ["Label", { location: [0.5, -0.5], label: "Drop", cssClass: "endpointTargetLabel", visible: false }]
                ]
            },
            init: function (connection) {
                connection.getOverlay("label").setLabel(connection.sourceId.substring(15) + "-" + connection.targetId.substring(15));
            }
        }
        jsPlumb.bind("ready", function () {
            var layout = document.getElementById("jsLayout");
            sortable(document.getElementById('list'), function (item, evt) {
                var startPoint = _isInCanvas(evt, layout);
                if (startPoint) {
                    _createElements(startPoint, item.dataset.deviceType)
                }
            });
            var instance = jsPlumb.getInstance({
                Endpoint: ["Dot", { radius: 2 }],
                HoverPaintStyle: { strokeStyle: "#1e8151", lineWidth: 2 },
                ConnectionOverlays: [
                    ["Arrow", { location: 1, id: "arrow", length: 10, foldback: 0.8, width: 10 }],
                    ["Label", { label: "", id: "label", cssClass: "labelstyle" }]
                ],
                DragOptions: { zIndex: 2000 },
                Cantainer: "jsLayout"
            });
            instance.registerConnectionType("basic", jspConfig.basicType);
            function _addElement(newId) {
                instance.draggable(newId);
                var eps = jsPlumb.getSelector(".dragPoint");
                console.log(eps)
                for (var i = 0; i < eps.length; i++) {
                    var e = eps[i], p = e.parentNode;
                    instance.makeSource(e, { parent: p, anchor: "Continuous" }, jspConfig.sourceEndpoint);
                }
                instance.makeTarget(newId, { dropOptions: { hoverClass: "dragHover" }, anchor: "Continuous" }, jspConfig.sourceEndpoint);
            };
            // suspend drawing and initialise.
            instance.batch(function () {
                // listen for new connections; initialise them the same way we initialise the connections at startup.
                instance.bind("connection", function (connInfo, originalEvent) {
                    jspConfig.init(connInfo.connection);
                });
                // make all the window divs draggable
                // instance.draggable(jsPlumb.getSelector(jsLayout), { grid: [20, 20] });

                //
                // listen for clicks on connections, and offer to delete connections on click.
                //
                instance.bind("click", function (conn, originalEvent) {
                    // if (confirm("Delete connection from " + conn.sourceId + " to " + conn.targetId + "?"))
                    //   instance.detach(conn);
                    conn.toggleType("basic");
                });

                instance.bind("connectionDrag", function (connection) {
                    console.log("connection " + connection.id + " is being dragged. suspendedElement is ", connection.suspendedElement, " of type ", connection.suspendedElementType);
                });

                instance.bind("connectionDragStop", function (connection) {
                    console.log("connection " + connection.id + " was dragged");
                });

                instance.bind("connectionMoved", function (params) {
                    console.log("connection " + params.connection.id + " was moved");
                });
            });

            jsPlumb.fire("jsPlumbLoaded", instance);
            function _createElements(startPoint, eleType) {
                var now = new Date();
                var len = now.getMilliseconds();
                var node = {
                    id: "element_" + eleType + "_" + now.getMinutes() + now.getMilliseconds(),
                    left: startPoint.x + "px",
                    top: startPoint.y + "px",
                    text: "节点" + len,
                    type: eleType,
                    icon: "glyphicon glyphicon-text-size"
                }
                var div = "<div class='dragPoint monitorObj' style='left:" + node.left + ";top:" + node.top + "' id='" + node.id
                    + "'><i class='" + node.icon + "'></i>" + node.text + "</div>";
                document.getElementById("jsLayout").innerHTML += div;
                _addElement(node.id);
            }
            function _isInCanvas(evt, toElements) {//判断是否在相应的元素内
                var startPoint;
                if (toElements && evt && toElements.getBoundingClientRect()) {
                    ePosition = toElements.getBoundingClientRect();
                    if ((evt.clientX > ePosition.left && evt.clientX < ePosition.left + toElements.offsetWidth)
                        && (evt.clientY > ePosition.top && evt.clientY < ePosition.top + toElements.offsetHeight)) {
                        startPoint = { x: 0, y: 0 };
                        startPoint.x = (evt.clientX - ePosition.left).toFixed(2);
                        startPoint.y = (evt.clientY - ePosition.top).toFixed(2);
                    }
                }
                return startPoint;
            };
        });
    })()
    
</script>